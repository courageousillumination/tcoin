import { hash, verifySignature } from "../../common/crypto";
import { TransactionManager } from "./transactionManager";

interface BitcoinTransaction {
  /**
   * ID for this transaction.
   *
   * Should be generated by hashing the remainder of the transaction.
   */
  id: string;

  /** Inputs going into this transaction. */
  inputs: TransactionInput[];

  /** Outputs coming from this transaction. */
  outputs: TransactionOutput[];
}

interface TransactionInput {
  /** The transaction this one is based off. */
  previousTransaction: string;

  /** Index to find the exact output in the previous transaction. */
  previousTransactionIndex: number;

  /**
   * A signature for this transaction.
   *
   * See below for details about the signing, but generally this should cover
   * all non signature, non-id bytes of the transaction.
   */
  signature: string;
}

interface TransactionOutput {
  /** Number of TCoin to be transfered to the output. */
  amount: number;

  /**
   * Public key of the target address.
   * NOTE: Full bitcoin uses a scripting language here, but we're just simplifying.
   */
  publicKey: string;
}

/**
 * Gets the part of the transaction that should have a signature applied.
 *
 * This should return the entire body, except for the signature components
 * (since it's impossible to sign your own signature).
 * @param transaction
 */
const getSignableTransaction = (transaction: BitcoinTransaction): string => {
  return JSON.stringify({
    inputs: transaction.inputs.map((x) => ({
      previousTransaction: x.previousTransaction,
      previousTransactionIndex: x.previousTransactionIndex,
    })),
    outputs: transaction.outputs,
  });
};

/**
 * Create a hash of the transaction (used for unique IDs)
 * @param transaction
 * @returns
 */
const hashTransaction = (transaction: Omit<BitcoinTransaction, "id">) => {
  return hash(
    JSON.stringify({
      inputs: transaction.inputs,
      outputs: transaction.outputs,
    })
  );
};

/**
 * Creates a transaction with the correct id.
 * @param transaction
 * @returns
 */
const idTransaction = (
  transaction: Omit<BitcoinTransaction, "id">
): BitcoinTransaction => {
  return {
    ...transaction,
    id: hashTransaction(transaction),
  };
};

class BitcoinTransactionManager
  implements TransactionManager<BitcoinTransaction, BitcoinTransaction[]>
{
  /** Transactions waiting to be committed. */
  private mempool: BitcoinTransaction[] = [];

  /**
   * All committed transactions that we know about.
   */
  private committedTransactions: BitcoinTransaction[] = [];

  constructor(private readonly getPublicKey: () => string) {}

  /** @override */
  public async addTransaction(transaction: BitcoinTransaction) {
    if (!(await this.validateTransaction(transaction))) {
      return false;
    }

    if (this.mempool.find((x) => x.id === transaction.id)) {
      return false;
    }

    this.mempool.push(transaction);
    return true;
  }

  /** @override */
  public async apply(data: BitcoinTransaction[]) {
    const coinbase = data[0];
    if (!this.validateCoinbase(coinbase)) {
      return false;
    }
    for (const transaction of data.slice(1)) {
      if (!(await this.validateTransaction(transaction))) {
        return false;
      }
    }
    this.committedTransactions = this.committedTransactions.concat(data);
    return true;
  }

  /** @override */
  public async rollback(data: BitcoinTransaction[]) {
    for (const transaction of data) {
      const old = this.committedTransactions.pop();
      if (!old || old.id !== transaction.id) {
        console.warn("Rollback incorrectly applied.");
      }
    }
  }

  /** @override */
  public async getCommit() {
    await this.validateMempool();
    return [this.getCoinbase(), ...this.mempool];
  }

  /**
   * Gets the set of all UTXO.
   * @returns
   */
  public getUtxoSet(): Map<string, Map<number, TransactionOutput>> {
    const finalSet = new Map<string, Map<number, TransactionOutput>>();
    for (const transaction of this.committedTransactions) {
      const outputs = new Map();
      for (let i = 0; i < transaction.outputs.length; i++) {
        outputs.set(i, transaction.outputs[i]);
      }
      finalSet.set(transaction.id, outputs);
    }

    // Clear out everything that's been spent.
    for (const transaction of this.committedTransactions) {
      for (const input of transaction.inputs) {
        finalSet
          .get(input.previousTransaction)
          ?.delete(input.previousTransactionIndex);
      }
    }
    return finalSet;
  }

  /**
   * Validadte everything in the mempool.
   *
   * Discard transactions that are not valid.
   */
  private async validateMempool() {
    const newPool = [];
    for (const transaction of this.mempool) {
      if (await this.validateTransaction(transaction)) {
        newPool.push(transaction);
      }
    }
    this.mempool = newPool;
  }

  /**
   * Ensure that a transaction is valid.
   * @param transaction
   * @returns
   */
  private async validateTransaction(transaction: BitcoinTransaction) {
    const utxoSet = this.getUtxoSet();

    const outputs: TransactionOutput[] = [];
    for (const input of transaction.inputs) {
      const output = utxoSet
        .get(input.previousTransaction)
        ?.get(input.previousTransactionIndex);
      if (output === undefined) {
        return false;
      }
      outputs.push(output);
    }

    // Verify that the amounts add up.
    const outputSum = transaction.outputs.reduce((acc, x) => acc + x.amount, 0);
    const inputSum = outputs.reduce((acc, x) => acc + x.amount, 0);

    // Add this back in just a second.
    if (outputSum !== inputSum) {
      return false;
    }

    // Verify that the signatures match.
    const transactionBody = getSignableTransaction(transaction);
    for (let i = 0; i < transaction.inputs.length; i++) {
      const input = transaction.inputs[i];
      const output = outputs[i];
      if (
        !(await verifySignature(
          transactionBody,
          input.signature,
          output.publicKey
        ))
      ) {
        return false;
      }
    }

    return true;
  }

  /**
   * Validates the coinbase transaction.
   * @param transaction
   * @returns
   */
  private validateCoinbase(transaction: BitcoinTransaction | undefined) {
    if (!transaction) {
      return false;
    }
    return true;
  }

  /**
   * Builds a coinbase transaction.
   * @returns
   */
  private getCoinbase(): BitcoinTransaction {
    return idTransaction({
      inputs: [],
      outputs: [{ publicKey: this.getPublicKey(), amount: 1000 }],
    });
  }
}

export {
  BitcoinTransaction,
  BitcoinTransactionManager,
  TransactionInput,
  TransactionOutput,
  hashTransaction,
  getSignableTransaction,
};
